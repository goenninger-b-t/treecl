// TreeCL REPL - Full Common Lisp REPL
//
// Uses Reader, Evaluator, and Printer for a complete read-eval-print loop.

use std::io::{self, Write, BufRead};
use triage_rs::reader::read_from_string;
use triage_rs::printer::print_to_string;
use triage_rs::eval::{Interpreter, Environment};
use triage_rs::primitives::register_primitives;

fn main() -> io::Result<()> {
    println!("TreeCL v0.2.0 - ANSI Common Lisp on Tree Calculus");
    println!("Type (quit) or Ctrl-D to exit");
    println!();
    
    let mut interp = Interpreter::new();
    
    // Register all built-in primitives
    register_primitives(&mut interp);
    
    let stdin = io::stdin();
    let mut stdout = io::stdout();
    
    loop {
        print!("CL-USER> ");
        stdout.flush()?;
        
        let mut input = String::new();
        if stdin.lock().read_line(&mut input)? == 0 {
            println!("\nGoodbye!");
            break;
        }
        
        let trimmed = input.trim();
        if trimmed.is_empty() {
            continue;
        }
        
        // Check for quit command
        if trimmed == "(quit)" || trimmed == "(exit)" {
            println!("Goodbye!");
            break;
        }
        
        // Read
        match read_from_string(trimmed, &mut interp.arena, &mut interp.symbols) {
            Ok(expr) => {
                // Eval
                let env = Environment::new();
                match interp.eval(expr, &env) {
                    Ok(result) => {
                        // Print
                        let output = print_to_string(&interp.arena, &interp.symbols, result);
                        println!("{}", output);
                    }
                    Err(signal) => {
                        println!("Control signal: {:?}", signal);
                    }
                }
            }
            Err(e) => {
                println!("Read error: {}", e);
            }
        }
    }
    
    Ok(())
}
