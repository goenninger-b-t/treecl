use std::io::{self, Write};
use std::collections::HashMap;
use triage_rs::arena::{Graph, NodeId};
use triage_rs::engine::{self, EvalContext, reduce};
use triage_rs::parser::Parser;


fn main() -> io::Result<()> {
    println!("Triage Rust REPL v0.1.0");
    println!("Type :q to quit.");

    let mut g = Graph::new();
    let mut env: HashMap<String, NodeId> = HashMap::new();
    
    // Register Primitives
    // Helper functions for Tagging
    // d{x} = Stem(Stem(x))
    fn make_stem(g: &mut Graph, x: NodeId) -> NodeId {
         g.add(triage_rs::arena::Node::Stem(x))
    }
    fn make_d(g: &mut Graph, x: NodeId) -> NodeId {
         make_stem(g, x)
    }
    // tag{t, f} = d{t}(d{f}(KK))
    // KK = K applied to K.
    // K = (n n).
    // KK = (n n) (n n).
    fn make_tag(g: &mut Graph, t: NodeId, f: NodeId) -> NodeId {
         let dt = make_d(g, t);
         let df = make_d(g, f);
         let leaf = g.add(triage_rs::arena::Node::Leaf);
         let k = g.add(triage_rs::arena::Node::Fork(leaf, leaf));
         let kk = g.add(triage_rs::arena::Node::Fork(k, k));
         
         // inner = d{f} KK
         let inner = g.add(triage_rs::arena::Node::App { func: df, args: smallvec::smallvec![kk] });
         
         // res = d{t} inner
         g.add(triage_rs::arena::Node::App { func: dt, args: smallvec::smallvec![inner] })
    }

    // Register Primitives
    use triage_rs::arena::Primitive;
    // Define Primitives using Node::Prim
    let add_prim = g.add(triage_rs::arena::Node::Prim(Primitive::Add));
    let sub_prim = g.add(triage_rs::arena::Node::Prim(Primitive::Sub));
    let mul_prim = g.add(triage_rs::arena::Node::Prim(Primitive::Mul));
    let div_prim = g.add(triage_rs::arena::Node::Prim(Primitive::Div));
    let mod_prim = g.add(triage_rs::arena::Node::Prim(Primitive::Mod));
    
    let cons_prim = g.add(triage_rs::arena::Node::Prim(Primitive::Cons));
    let first_prim = g.add(triage_rs::arena::Node::Prim(Primitive::First));
    let rest_prim = g.add(triage_rs::arena::Node::Prim(Primitive::Rest));
    let eq_prim = g.add(triage_rs::arena::Node::Prim(Primitive::Eq));
    
    let is_num_prim = g.add(triage_rs::arena::Node::Prim(Primitive::IsNum));
    let is_str_prim = g.add(triage_rs::arena::Node::Prim(Primitive::IsStr));
    let is_char_prim = g.add(triage_rs::arena::Node::Prim(Primitive::IsChar));
    let is_prog_prim = g.add(triage_rs::arena::Node::Prim(Primitive::IsProg));
    let is_neg_prim = g.add(triage_rs::arena::Node::Prim(Primitive::IsNeg));
    let is_prim_prim = g.add(triage_rs::arena::Node::Prim(Primitive::IsPrim));
    let size_prim = g.add(triage_rs::arena::Node::Prim(Primitive::Size));
    let contains_prim = g.add(triage_rs::arena::Node::Prim(Primitive::Contains));
    let match_prim = g.add(triage_rs::arena::Node::Prim(Primitive::Match));
    let any_prim = g.add(triage_rs::arena::Node::Prim(Primitive::Any));
    
    // Create Tags (Integers 1..N)
    // 1: Add, 2: Sub, 3: Mul, 4: Div, 5: Mod
    // 6: Cons, 7: First, 8: Rest, 9: Eq
    // ...
    let tag_1 = engine::encode_int(&mut g, &num_bigint::BigInt::from(1));
    let tag_2 = engine::encode_int(&mut g, &num_bigint::BigInt::from(2));
    let tag_3 = engine::encode_int(&mut g, &num_bigint::BigInt::from(3));
    let tag_4 = engine::encode_int(&mut g, &num_bigint::BigInt::from(4));
    let tag_5 = engine::encode_int(&mut g, &num_bigint::BigInt::from(5));
    let tag_6 = engine::encode_int(&mut g, &num_bigint::BigInt::from(6));
    let tag_7 = engine::encode_int(&mut g, &num_bigint::BigInt::from(7));
    let tag_8 = engine::encode_int(&mut g, &num_bigint::BigInt::from(8));
    let tag_9 = engine::encode_int(&mut g, &num_bigint::BigInt::from(9));
    let tag_10 = engine::encode_int(&mut g, &num_bigint::BigInt::from(10));
    let tag_11 = engine::encode_int(&mut g, &num_bigint::BigInt::from(11));
    let tag_12 = engine::encode_int(&mut g, &num_bigint::BigInt::from(12));
    let tag_13 = engine::encode_int(&mut g, &num_bigint::BigInt::from(13));
    let tag_14 = engine::encode_int(&mut g, &num_bigint::BigInt::from(14));
    let tag_15 = engine::encode_int(&mut g, &num_bigint::BigInt::from(15));
    let tag_16 = engine::encode_int(&mut g, &num_bigint::BigInt::from(16));
    let tag_17 = engine::encode_int(&mut g, &num_bigint::BigInt::from(17));
    let tag_18 = engine::encode_int(&mut g, &num_bigint::BigInt::from(18));
    let tag_19 = engine::encode_int(&mut g, &num_bigint::BigInt::from(19));
    let tag_20 = engine::encode_int(&mut g, &num_bigint::BigInt::from(20));
    let tag_21 = engine::encode_int(&mut g, &num_bigint::BigInt::from(21));
    let tag_22 = engine::encode_int(&mut g, &num_bigint::BigInt::from(22));
    let tag_23 = engine::encode_int(&mut g, &num_bigint::BigInt::from(23));
    let tag_24 = engine::encode_int(&mut g, &num_bigint::BigInt::from(24));
    let tag_25 = engine::encode_int(&mut g, &num_bigint::BigInt::from(25));
    let tag_26 = engine::encode_int(&mut g, &num_bigint::BigInt::from(26));
    let tag_27 = engine::encode_int(&mut g, &num_bigint::BigInt::from(27));
    let tag_28 = engine::encode_int(&mut g, &num_bigint::BigInt::from(28));
    let tag_29 = engine::encode_int(&mut g, &num_bigint::BigInt::from(29));

    // Create Tagged Primitives
    let add_id = make_tag(&mut g, tag_1, add_prim);
    let sub_id = make_tag(&mut g, tag_2, sub_prim);
    let mul_id = make_tag(&mut g, tag_3, mul_prim);
    let div_id = make_tag(&mut g, tag_4, div_prim);
    let mod_id = make_tag(&mut g, tag_5, mod_prim);
    
    let cons_id = make_tag(&mut g, tag_6, cons_prim);
    
    // Arity-1 primitives should NOT be tagged as they must execute immediately
    let first_id = first_prim;
    let rest_id = rest_prim;
    
    let eq_id = make_tag(&mut g, tag_9, eq_prim);
    
    let is_num_id = is_num_prim;
    let is_str_id = is_str_prim;
    let is_char_id = is_char_prim;
    let is_prog_id = is_prog_prim;
    let is_neg_id = is_neg_prim;
    let _is_prim_id = is_prim_prim;
    let _size_id = size_prim;
    
    let _contains_id = make_tag(&mut g, tag_17, contains_prim);
    let _match_id = make_tag(&mut g, tag_18, match_prim);
    let _any_id = any_prim;

    // Bindings
    env.insert("add".to_string(), add_id);
    env.insert("+".to_string(), add_id);
    
    env.insert("sub".to_string(), sub_id);
    env.insert("-".to_string(), sub_id);
    
    env.insert("mul".to_string(), mul_id);
    env.insert("*".to_string(), mul_id);
    
    env.insert("div".to_string(), div_id);
    env.insert("/".to_string(), div_id);
    
    env.insert("mod".to_string(), mod_id);
    env.insert("%".to_string(), mod_id);
    
    env.insert("cons".to_string(), cons_id);
    env.insert("first".to_string(), first_id);
    env.insert("rest".to_string(), rest_id);
    env.insert("eq".to_string(), eq_id);
    env.insert("=".to_string(), eq_id);
    env.insert("equal".to_string(), eq_id);
    // Duplicate cons insertions in original code removed for cleanliness
    env.insert("n".to_string(), g.add(triage_rs::arena::Node::Leaf));
    
    env.insert("number?".to_string(), is_num_id);
    env.insert("string?".to_string(), is_str_id);
    env.insert("char?".to_string(), is_char_id);
    env.insert("program?".to_string(), is_prog_id);
    env.insert("neg?".to_string(), is_neg_id);
    // Register primitives
    // NOTE: We only tag primitives that act as "constructors" or have arity >= 2 where the first argument
    // creates a tagged cell (Scott encoding style). Arity-1 execution primitives (first, rest, predicates)
    // should NOT be tagged, as they must execute immediately.
    
    let primitives = vec![
        ("cons", Primitive::Cons, tag_6, false), // Untagged Cons for Native Lists
        ("add", Primitive::Add, tag_1, true),
        ("sub", Primitive::Sub, tag_2, true),
        ("mul", Primitive::Mul, tag_3, true),
        ("div", Primitive::Div, tag_4, true),
        ("mod", Primitive::Mod, tag_5, true),
        ("eq", Primitive::Eq, tag_9, true),
        ("contains?", Primitive::Contains, tag_17, true),
        ("match?", Primitive::Match, tag_18, true),
        
        ("first", Primitive::First, tag_7, true), // TAGGED (Auto-unwrap handles execution)
        ("rest", Primitive::Rest, tag_8, true),
        ("number?", Primitive::IsNum, tag_10, true),
        ("string?", Primitive::IsStr, tag_11, true),
        ("char?", Primitive::IsChar, tag_12, true),
        ("program?", Primitive::IsProg, tag_13, true),
        ("neg?", Primitive::IsNeg, tag_14, true),
        ("prim?", Primitive::IsPrim, tag_15, true),
        ("size", Primitive::Size, tag_16, true),
        ("any", Primitive::Any, tag_19, true), // Arity 0/special
        ("search-step", Primitive::SearchStep, tag_19, false), // Arity 4
        
        // Float primitives
        ("int->float", Primitive::IntToFloat, tag_20, true),
        ("float->int", Primitive::FloatToInt, tag_21, true),
        ("float?", Primitive::IsFloat, tag_22, true),
        ("floor", Primitive::Floor, tag_23, true),
        ("ceil", Primitive::Ceil, tag_24, true),
        ("sqrt", Primitive::Sqrt, tag_25, true),
        ("sin", Primitive::Sin, tag_26, true),
        ("cos", Primitive::Cos, tag_27, true),
        ("tan", Primitive::Tan, tag_28, true),
        ("abs-prim", Primitive::Abs, tag_29, true), // Map abs to this or lambda? Lambda is fine since Abs primitive is polymorphic now.
        // Actually replacing abs lambda with primitive is more efficient.
    ];

    for (name, prim_enum, tag_node_id, should_tag) in primitives {
        let prim_node = g.add(triage_rs::arena::Node::Prim(prim_enum));
        let val = if should_tag {
            make_tag(&mut g, tag_node_id, prim_node)
        } else {
            prim_node
        };
        env.insert(name.to_string(), val);
    }

    // Add aliases
    env.insert("+".to_string(), *env.get("add").unwrap());
    env.insert("-".to_string(), *env.get("sub").unwrap());
    env.insert("*".to_string(), *env.get("mul").unwrap());
    env.insert("/".to_string(), *env.get("div").unwrap());
    env.insert("%".to_string(), *env.get("mod").unwrap());
    env.insert("=".to_string(), *env.get("eq").unwrap());
    env.insert("equal".to_string(), *env.get("eq").unwrap());
    
    // Load Prelude
    let prelude = [
        "(def _ n)",
        "(def K (n n))",
        "(def I (fn x x))",
        "(def const K)",
        "(def id I)",
        "(def force I)",
        "(def pair n)",
        // "(def cons pair)", // We use native cons
        "(def true (n n))",
        "(def false n)",
        "(def compose (fn f (fn g (fn x (f (g x))))))",
        "(def triage (fn leaf (fn stem (fn fork (n (n leaf stem) fork)))))",
        "(def query triage)",
        "(def matchList (fn a (fn b (triage a n b))))",
        "(def if (fn p (fn t (fn f (triage f (fn _ t) (fn _ (fn _ t)) p)))))",
        "(def emptyList? (matchList true (fn _ (fn _ false))))",
        
        // Efficient selectors - mapped to native primitives or aliases
        // "(def head fork_lhs)", ... handled by native first/rest already, but maybe aliased?
        // Let's rely on native first/rest mapping in env above.
        
        "(def y (fn f ((fn x (f (x x))) (fn x (f (x x))))))",
        "(def Z y)",
        // map: note this depends on functional cons which we replaced with native cons
        // If native cons is opaque, can we decompose it using matchList?
        // primitive-list-rewrite supports matchList on native lists.
        // matchList (fn _ nil_val) (fn h t cons_val) list
        // My native cons emits Fork(h, t).
        // My matchList definition: (def matchList (fn a (fn b (triage a n b))))
        // triage on Fork(h, t) -> b h t.
        // So yes, it works!
        
        "(def map_ (y (fn self (matchList (fn _ n) (fn head (fn tail (fn f (cons (f head) (self tail f)))))))))",
        "(def map (fn f (fn l (map_ l f))))",
        
        "(def matchBool (fn ot (fn of (triage of (fn _ ot) (fn _ (fn _ ot))))))",
        "(def not? (matchBool false true))",
        "(def and? (matchBool id (fn _ false)))",
        "(def or? (fn x (fn z (matchBool (matchBool true true z) (matchBool true false z) x))))",
        "(def xor? (fn x (fn z (matchBool (matchBool false true z) (matchBool true false z) x)))))",
        
        // Range support
        // matchList takes (nil_case, cons_case). Result applied to list.
        "(def is_pos? (fn n (triage false true (fn _ (fn _ true)) n)))",
        "(def < (fn a (fn b (is_pos? (- b a)))))",
        "(def inc (fn x (+ x 1)))",
        "(def dec (fn x (- x 1)))",
        "(def range_gen (fn self (fn s (fn e (if (< s e) (cons s (self (inc s) e)) n)))))",
        "(def range (Z range_gen))", // Start End
        
        "(def abs abs-prim)",
        
        "(def range_gen_inf (fn self (fn s (cons s (self (inc s))))))",
        "(def rangeFrom (Z range_gen_inf))", // Infinite from start
        
        "(def rangeTo (fn e (range 0 e)))", // 0 to End
        
        // Repeat
        "(def repeat_gen (fn self (fn x (cons x (self x)))))",
        "(def repeat (Z repeat_gen))",
        
        // Take support
        // take n coll
        "(def take_gen (fn self (fn n (fn coll (if (is_pos? n) (matchList coll (fn h (fn t (cons h (self (dec n) t)))) n) n)))))",
        "(def take (Z take_gen))",

        // Reduce
        "(def reduce_gen (fn self (fn rf (fn acc (fn c (matchList acc (fn h (fn t (self rf (rf acc h) t))) c))))))",
        "(def reduce (Z reduce_gen))",

        // Filter
        "(def filter_gen (fn self (fn p (fn l (matchList n (fn h (fn t (if (p h) (cons h (self p t)) (self p t)))) l)))))",
        "(def filter (Z filter_gen))",

        // Utilities
        "(def concat (Z (fn self (fn xs (fn ys (matchList ys (fn h (fn t (cons h (self t ys)))) xs))))))",
    ];
    
    for def_str in &prelude {
        let mut p = Parser::new(def_str);
        if let Ok(triage_rs::parser::ParseResult::Def(name, val)) = p.parse_toplevel(&mut g, Some(&env)) {
            env.insert(name, val);
        } else {
             println!("Warning: Failed to load prelude: {}", def_str);
        }
    }
    
    let stdin = io::stdin();
    let mut stdout = io::stdout();
    let mut input_buffer = String::new();
    let mut code_buffer = String::new();

    loop {
        if code_buffer.trim().is_empty() {
            print!("> ");
        } else {
            print!("... ");
        }
        stdout.flush()?;

        input_buffer.clear();
        if stdin.read_line(&mut input_buffer)? == 0 {
            break; // EOF
        }
        
        code_buffer.push_str(&input_buffer);
        
        // Check balance
        if is_balanced(&code_buffer) {
            let trimmed = code_buffer.trim();
            if trimmed.is_empty() {
                code_buffer.clear();
                continue;
            }
            if trimmed == ":q" {
                break;
            }
            if trimmed.starts_with(':') {
                if trimmed.starts_with(":search") {
                    let parts: Vec<&str> = trimmed.split_whitespace().collect();
                         if parts.len() == 1 {
                             // :search -> Demo
                             triage_rs::search::search_demo(&mut g);
                         } else if parts.len() >= 2 {
                             // :search <data> [scorer | steps] [steps | seed] [seed]
                             let var_name = parts[1];
                             
                             let mut steps = 5000;
                             let mut scorer: Option<triage_rs::arena::NodeId> = None;
                             let mut raw_seed: Option<NodeId> = None;
                             
                             // Helper to try parsing int or lookup var
                             fn parse_arg(arg: &str, env: &HashMap<String, NodeId>) -> (Option<usize>, Option<NodeId>) {
                                 if let Ok(s) = arg.parse::<usize>() {
                                     (Some(s), None)
                                 } else if let Some(&id) = env.get(arg) {
                                     (None, Some(id))
                                 } else {
                                     (None, None)
                                 }
                             }

                             // Parse optional arguments greedily
                             // Arg 2
                             if parts.len() >= 3 {
                                 let (s, id) = parse_arg(parts[2], &env);
                                 if let Some(s_val) = s { steps = s_val; }
                                 else if let Some(id_val) = id { scorer = Some(id_val); }
                                 else { println!("Warning: Argument '{}' not found/invalid.", parts[2]); }
                             }
                             // Arg 3
                             if parts.len() >= 4 {
                                 let (s, id) = parse_arg(parts[3], &env);
                                 if let Some(s_val) = s { steps = s_val; }
                                 else if let Some(id_val) = id { 
                                     if scorer.is_none() && raw_seed.is_none() { 
                                         // Ambiguous: Could be scorer or seed.
                                         // If arg 2 was steps (scorer none), then this is likely scorer OR seed.
                                         // Convention: Scorer, Steps, Seed.
                                         // If we have Steps but no Scorer, this is likely Scorer?
                                         // But users usually do: :search data diff 1000
                                         // If they do :search data 1000 diff -> arg2=steps, arg3=scorer
                                         // If they do :search data 1000 seed -> arg2=steps, arg3=seed
                                         // Hard to know. Let's assume Scorer if not set, else Seed.
                                         // Actually let's assume if it looks like a program, it's a seed?
                                         // Scorer is also a program.
                                         // Let's stick to strict order preference: Scorer, then Seed.
                                         if scorer.is_none() { scorer = Some(id_val); }
                                         else { raw_seed = Some(id_val); }
                                     } else {
                                         raw_seed = Some(id_val); 
                                     }
                                 }
                             }
                             // Arg 4
                             if parts.len() >= 5 {
                                let (_s, id) = parse_arg(parts[4], &env);
                                if let Some(id_val) = id { raw_seed = Some(id_val); }
                             }
                             
                             if let Some(&id) = env.get(var_name) {
                                 let mut ctx = EvalContext::default();
                                 let reduced_id = triage_rs::engine::reduce(&mut g, id, &mut ctx);
                                 
                                 // Check for List of Tasks first (Vec<Vec<Pair>>)
                                 let mut tasks: Vec<Vec<(NodeId, NodeId)>> = Vec::new();
                                 let mut valid_tasks = false;

                                 // Try to extract as list of items (potential tasks)
                                 if let Some(items) = triage_rs::search::extract_list(&mut g, reduced_id) {
                                      if !items.is_empty() {
                                          let first_item = items[0];
                                          // Check if first item is a list of pairs?
                                          if let Some(_) = triage_rs::search::extract_list(&mut g, first_item) {
                                              // It is a list of lists. Assume multi-task.
                                              let mut all_valid = true;
                                              for item in &items {
                                                  if let Some(pairs) = triage_rs::search::extract_pairs(&mut g, *item) {
                                                      tasks.push(pairs);
                                                  } else {
                                                      all_valid = false;
                                                      break;
                                                  }
                                              }
                                              if all_valid { valid_tasks = true; }
                                          } 
                                      } else {
                                          // Empty list can be empty task list OR empty data
                                          valid_tasks = true; 
                                          tasks.push(Vec::new());
                                      }
                                 }
                                 
                                 // Fallback: If not valid multi-task, check if single task
                                 if !valid_tasks {
                                     tasks.clear();
                                     if let Some(pairs) = triage_rs::search::extract_pairs(&mut g, reduced_id) {
                                         tasks.push(pairs); // Single task
                                         valid_tasks = true;
                                     }
                                 }
                                 
                                 if valid_tasks && !tasks.is_empty() {
                                     let total_examples: usize = tasks.iter().map(|t| t.len()).sum();
                                     println!("Running search with {} tasks ({} total examples) from '{}' for {} steps...", tasks.len(), total_examples, var_name, steps);
                                     
                                     // Process Seed
                                     let mut seeds = Vec::new();
                                     if let Some(sid) = raw_seed {
                                         if let Some(mut items) = triage_rs::search::extract_list(&mut g, sid) {
                                             seeds.append(&mut items);
                                         } else {
                                             seeds.push(sid);
                                         }
                                     }
                                     
                                     let pop_size = 5;
                                     // OOPS Policy: Ensure diversity by limiting survivors.
                                     // Keep at most pop_size / 2 seeds (or 1 if pop_size is small).
                                     let max_seeds = if pop_size > 1 { pop_size / 2 + 1 } else { 1 };
                                     if seeds.len() > max_seeds {
                                         println!("OOPS: Truncating seeds from {} to {} to ensure exploration.", seeds.len(), max_seeds);
                                         seeds.truncate(max_seeds);
                                     }
                                     
                                     let results = triage_rs::search::run_search(&mut g, &tasks, scorer, steps, seeds, pop_size);
                                     
                                     if !results.is_empty() {
                                         let best_id = results[0];
                                         env.insert("*best*".to_string(), best_id);
                                         
                                         // Construct *population* list (Cons p1 (Cons p2 ... n))
                                         // We need the Cons primitive ID.
                                         if let Some(&cons_id) = env.get("cons") {
                                              // We also need "n" (Leaf)
                                              let nil_id = g.add(triage_rs::arena::Node::Leaf);
                                              
                                              let mut list_node = nil_id;
                                              // Push in reverse order to preserve order (cons p1 (cons p2 ...))
                                              for &prog_id in results.iter().rev() {
                                                  // list_node = cons prog_id list_node
                                                  // We can't execute "cons" here easily without `run_program` or manual node construction.
                                                  // Manual construction of Scott Encoded Cons:
                                                  // Tag 6 is usually used.
                                                  // Let's just use `App(App(cons, prog), list)`.
                                                  // And reduce it?
                                                  
                                                  // Faster: Just construct the App tree.
                                                  // cons_id is the tagged primitive.
                                                  // Node::App { func: cons_id, args: [prog_id] } -> Returns function waiting for 2nd arg
                                                  // Node::App { func: above, args: [list_node] } -> Fully applied cons
                                                  
                                                  let step1 = g.add(triage_rs::arena::Node::App { 
                                                      func: cons_id, 
                                                      args: smallvec::smallvec![prog_id] 
                                                  });
                                                  list_node = g.add(triage_rs::arena::Node::App {
                                                      func: step1,
                                                      args: smallvec::smallvec![list_node]
                                                  });
                                              }
                                              
                                              // Reduce it to normalize? (Optional, but safe)
                                              let mut ctx = EvalContext::default();
                                              let list_node_reduced = triage_rs::engine::reduce(&mut g, list_node, &mut ctx);
                                              
                                              env.insert("*population*".to_string(), list_node_reduced);
                                              println!("Bound result to *best* and *population*");
                                         }
                                     }
                                 } else {
                                     println!("Error: '{}' is not a valid list of pairs.", var_name);
                                 }
                             } else {
                                 println!("Error: Variable '{}' not found.", var_name);
                             }
                         } else {
                             println!("Usage: :search <data> [scorer] [steps] [seed]");
                         }
                         code_buffer.clear();
                         continue;
                }
                
                if trimmed.starts_with(":load") {
                     // Extract path
                     let rest = trimmed[5..].trim();
                     let path_str = if rest.starts_with('"') && rest.ends_with('"') {
                         &rest[1..rest.len()-1]
                     } else {
                         rest
                     };
                     
                     match std::fs::read_to_string(path_str) {
                         Ok(contents) => {
                             println!("Loading {}...", path_str);
                             let mut parser = Parser::new(&contents);
                             loop {
                                 // We need to check for EOF. peek() handles it.
                                 if parser.peek().is_none() { break; }
                                 
                                 match parser.parse_toplevel(&mut g, Some(&env)) {
                                     Ok(triage_rs::parser::ParseResult::Def(name, val)) => {
                                         env.insert(name.clone(), val);
                                         println!("Defined {}", name);
                                     }
                                     Ok(triage_rs::parser::ParseResult::Term(root)) => {
                                         let mut ctx = EvalContext::default();
                                         let _result = reduce(&mut g, root, &mut ctx);
                                         // Don't print result for loaded files unless verbose?
                                         // But REPL usually prints loaded output? 
                                         // Let's print steps or result if simple.
                                         // Just suppress checks for load usually.
                                     }
                                     Err(e) => {
                                         println!("Error loading file: {}", e);
                                         break; 
                                     }
                                 }
                             }
                             println!("Load complete.");
                         }
                         Err(e) => println!("Error loading file: {}", e),
                     }
                     code_buffer.clear();
                     continue;
                }

                println!("Unknown command: {}", trimmed);
                code_buffer.clear();
                continue;
            }
            
            let mut p = Parser::new(trimmed);
            match p.parse_toplevel(&mut g, Some(&env)) {
                Ok(triage_rs::parser::ParseResult::Def(name, val)) => {
                    env.insert(name.clone(), val);
                    println!("#<Var: {}>", name);
                }
                Ok(triage_rs::parser::ParseResult::Term(root)) => {
                    let mut ctx = EvalContext::default();
                    let result = reduce(&mut g, root, &mut ctx);
                    
                    if engine::is_true(&g, result) {
                        println!("true");
                    } else {
                        let (_inner, tag) = engine::unwrap_data(&g, result);
                        let handled = if let Some(t) = tag {
                             match t {
                                 triage_rs::arena::Primitive::TagStr => {
                                     if let Some(s) = engine::decode_str(&g, result) {
                                         println!("{:?}", s);
                                         true
                                     } else { false }
                                 }
                                 triage_rs::arena::Primitive::TagChar => {
                                     if let Some(c) = engine::decode_char(&g, result) {
                                         println!("'{}'", c);
                                         true
                                     } else { false }
                                 }
                                 _ => false
                             }
                        } else { false };
                        
                        if !handled {
                            if let Some(n) = engine::decode_int(&g, result) {
                                println!("{}", n);
                            } else {
                                 println!("{}", engine::unparse(&g, result));
                            }
                        }
                    }
                    println!("Steps: {}", ctx.steps);
                }
                Err(e) => {
                    println!("Parse error: {}", e);
                }
            }
            code_buffer.clear();
        }
    }
    Ok(())
}

fn is_balanced(s: &str) -> bool {
    let mut balance = 0;
    let mut in_comment = false;
    for c in s.chars() {
        if in_comment {
             if c == '\n' { in_comment = false; }
             continue;
        }
        match c {
            ';' => in_comment = true,
            '(' => balance += 1,
            ')' => balance -= 1,
            _ => {}
        }
    }
    balance <= 0
}
